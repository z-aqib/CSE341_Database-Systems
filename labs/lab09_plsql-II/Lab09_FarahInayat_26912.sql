-- QUESTION 1
CREATE TABLE CUSTOMER
(
 CID VARCHAR2(3) PRIMARY KEY,
 CNAME VARCHAR2(25),
 CREDIT_LIMIT NUMBER,
 CREDIT_BALANCE NUMBER
);

INSERT INTO CUSTOMER VALUES ('C81','Alpha',99,0);
INSERT INTO CUSTOMER VALUES ('C82','Bravo',700,0);
INSERT INTO CUSTOMER VALUES ('C83','Charlie',5000,0);
COMMIT;

CREATE TABLE SALES
(
 SID NUMBER PRIMARY KEY,
 SDATE DATE default SYSDATE,
 PCODE VARCHAR2(3),
 CID VARCHAR2(3),
 QTY NUMBER,
 RATE NUMBER,
 AMOUNT NUMBER,
 FOREIGN KEY (CID) REFERENCES CUSTOMER(CID)
);

--PART A
CREATE OR REPLACE TRIGGER SALES_Before_insert
BEFORE INSERT ON SALES
FOR EACH ROW
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = CREDIT_BALANCE + :new.AMOUNT
    WHERE CID = :new.CID; 
END;

INSERT INTO SALES (SID, SDATE, PCODE, CID, QTY, RATE, AMOUNT)
VALUES (1, SYSDATE, 'P01', 'C81', 1, 100, 100);

SELECT CID, CNAME, CREDIT_BALANCE
FROM CUSTOMER
WHERE CID = 'C81';

SELECT * FROM SALES;

--PART B
CREATE OR REPLACE TRIGGER SALES_Before_Del
BEFORE DELETE ON SALES
FOR EACH ROW
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = CREDIT_BALANCE - :old.AMOUNT
    WHERE CID = :old.CID;
END;

DELETE FROM SALES WHERE SID = 1;
SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

--PART C
DROP TRIGGER SALES_Before_insert;
DROP TRIGGER SALES_Before_Del;

CREATE OR REPLACE TRIGGER SALES_Insert_Del
AFTER INSERT OR DELETE ON SALES
FOR EACH ROW
BEGIN
     IF INSERTING THEN
     UPDATE CUSTOMER
     SET CREDIT_BALANCE = CREDIT_BALANCE + :new.AMOUNT
     WHERE CID = :new.CID; 
     ELSIF DELETING THEN
     UPDATE CUSTOMER
     SET CREDIT_BALANCE = CREDIT_BALANCE - :old.AMOUNT
     WHERE CID = :old.CID;
     END IF;
END;

INSERT INTO SALES (SID, SDATE, PCODE, CID, QTY, RATE, AMOUNT)
VALUES (1, SYSDATE, 'P01', 'C81', 1, 100, 100);

SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

DELETE FROM SALES WHERE SID = 1;

SELECT * FROM SALES;
SELECT * FROM CUSTOMER;

-- QUESTION 2
-- PART A
CREATE TABLE ORDERS ( 
order_id number(5) PRIMARY KEY,
quantity number(4), 
cost_per_item number(6,2), 
total_cost number(8,2), 
discount number(2),
final_charged number(8,2)
);

--PART B
CREATE OR REPLACE TRIGGER calculate_totalcosts
BEFORE INSERT ON ORDERS
FOR EACH ROW
BEGIN
    :new.total_cost := :new.quantity * :new.cost_per_item;
    :new.final_charged := :new.total_cost - (:new.total_cost * :new.discount / 100);
END;

--PART C:
INSERT INTO ORDERS(order_id, quantity, cost_per_item,discount) 
VALUES (1,10, 200,25);
SELECT * FROM ORDERS;

--PART D
INSERT INTO ORDERS(order_id, quantity, cost_per_item,discount) 
VALUES (2,20, 300,25);

SELECT * FROM ORDERS;

--QUESTION 3
--PART A: 
CREATE TABLE Currency_con (
    CID VARCHAR2(3) PRIMARY KEY,
    currency VARCHAR2(50),
    rate NUMBER(10, 2)  
);

CREATE TABLE fluctuations (
    recDate DATE,
    currency VARCHAR2(50),
    difference NUMBER(10, 2)
);

--PART B: 
INSERT INTO Currency_con (CID, Currency, Rate) VALUES ('USD', 'US Dollar', 278.50);
INSERT INTO Currency_con (CID, Currency, Rate) VALUES ('GBP', 'British Pound', 346.75);

SELECT * FROM CURRENCY_CON;

--PART C: 
CREATE OR REPLACE TRIGGER currency_fluctuation_log
AFTER INSERT OR UPDATE ON CURRENCY_CON
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO FLUCTUATIONS (recDate, Currency, Difference)
        VALUES (SYSDATE, :new.Currency, 0);
        
    ELSIF UPDATING THEN
        INSERT INTO FLUCTUATIONS (recDate, Currency, Difference)
        VALUES (SYSDATE, :new.Currency, :new.Rate - :old.Rate);
    END IF;
END;

INSERT INTO Currency_con (CID, Currency, Rate) VALUES ('EUR', 'Euro', 300.00);
UPDATE Currency_con SET Rate = 285.00 WHERE CID = 'USD';


SELECT * FROM FLUCTUATIONS;

--QUESTION 4
--PART A: 
CREATE TABLE WORKER(
WORKERID INTEGER PRIMARY KEY,
LNAME VARCHAR2(255),
GENDER VARCHAR(1) CHECK(GENDER='F' OR GENDER='M'),
SALARY NUMBER(8,2),
COMMISSION NUMBER,
DEPT_ID INTEGER
);

--PART B:
CREATE Sequence WORKER_SEQ increment by 5 start with 100;

CREATE OR REPLACE TRIGGER WORKER_before_insert
BEFORE INSERT ON WORKER
FOR EACH ROW
    BEGIN
        
        :NEW.workerID := worker_seq.NEXTVAL;  -- Assign next value of sequence
        
END;

INSERT INTO worker (lname, gender, salary, commission, dept_ID)
VALUES ('Ali', 'M', 5000.00, 30.00, 101);
SELECT * FROM WORKER;

--QUESTION 5
--PART A
CREATE TABLE OrderHeader(
OrderID INTEGER PRIMARY KEY,
Odate DATE DEFAULT SYSDATE,
CustID INTEGER,
Total NUMBER
);

CREATE TABLE Order_Item(
OrderID INTEGER,
ItemID INTEGER,
QTY INTEGER,
SUBTOTAL NUMBER,
PRIMARY KEY(OrderID, ItemID),
FOREIGN KEY (OrderID) REFERENCES OrderHeader(OrderID)
);

PART B
CREATE OR REPLACE TRIGGER OrderItem_After_IUD
AFTER INSERT OR UPDATE OR DELETE ON Order_Item
    DECLARE
        CURSOR c_total IS
            SELECT OrderID AS OrderID, SUM(SUBTOTAL) AS TOTAL_AMOUNT
            FROM Order_Item
            GROUP BY OrderID;
    BEGIN        
        FOR V_total IN C_total LOOP
            UPDATE OrderHeader
            SET Total = V_total.TOTAL_AMOUNT
            WHERE OrderID = V_total.OrderID;
        END LOOP;
END;

INSERT INTO OrderHeader (OrderId, Odate, CustID) VALUES (1,SYSDATE, 1); 
INSERT INTO Order_Item VALUES (1,1, 20, 200); 
INSERT INTO Order_Item VALUES (1,2, 5, 100); 

SELECT * FROM ORDERHEADER;

--QUESTION 6
CREATE OR REPLACE FUNCTION average_dept_salary(dep_name IN VARCHAR2)
RETURN NUMBER
IS
    avg_sal NUMBER;
    BEGIN
        SELECT ROUND(AVG(SALARY), 2)
        INTO avg_sal
        FROM EMPLOYEES E
        INNER JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
        WHERE D.DEPARTMENT_NAME = dep_name;
        
        RETURN avg_sal;
END;

SELECT average_dept_salary('IT') FROM dual;

--QUESTION 7
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE REGION_MAX_SAL
IS
    CURSOR C_REGION_MAX IS
        SELECT MAX(E.SALARY) AS MAX_SAL, R.REGION_NAME AS REGION_NAME
        FROM EMPLOYEES E
        INNER JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
        INNER JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID 
        INNER JOIN COUNTRIES C ON C.COUNTRY_ID = L.COUNTRY_ID
        INNER JOIN REGIONS R ON R.REGION_ID = C.REGION_ID
        GROUP BY R.REGION_NAME;
    
    BEGIN
        FOR V_REGION_MAX IN C_REGION_MAX LOOP
            DBMS_OUTPUT.PUT_LINE(V_REGION_MAX.REGION_NAME || ': ' || V_REGION_MAX.MAX_SAL);
        END LOOP;
END;

BEGIN
    REGION_MAX_SAL
END;

--QUESTION 8
CREATE OR REPLACE FUNCTION COUNT_EMPLOYEES
RETURN COUNT
IS
    V_COUNT INTEGER
    BEGIN 
        SELECT COUNT(*) 
        INTO V_COUNT
        FROM (
            SELECT EMPLOYEE_ID
            FROM JOB_HISTORY
            GROUP BY EMPLOYEE_ID
            HAVING COUNT(*) > 1
        );
        
        RETURN V_COUNT;
END;

SELECT COUNT_EMPLOYEES FROM DUAL;
